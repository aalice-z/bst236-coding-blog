[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/xdcIkjOc)
# Homework 1: Code with AI

## üåê Website Link
**Live Site**: [https://aalice-z.github.io/bst236-coding-blog/](https://aalice-z.github.io/bst236-coding-blog/)


The due date is Feb 17 at midnight. If you are using the late days, please note in the head of README.md that ‚ÄúI used XX late days this time, and I have XX days remaining‚Äù.

The main purpose of this homework is to help you:

- Get experience with AI coding
- Learn how to decompose a problem into smaller tasks and find the right tools to solve them with the help of AI
- Improve your prompt engineering skills
- Conduct the coding task you have never learned before with the help of AI
- Learn the agentic programming paradigm

**Remark**: We expect you to complete the homework with the help of AI. The tips we provide are just suggestions, and you can use other tools to complete the tasks. This homework might take longer than you expect if you have no experience with game/web development or GitHub Actions. Though this is exactly what we expect you to experience: to finish the coding tasks that you have never learned before, we suggest you **start early** in case you face unexpected issues. 

Enjoy your vibe coding!

Your homework repository should have all the source code for the problems below, though the real website could be based on the repository hosted under your own GitHub account.

In the `README.md` of your homework repository, you can write the report section as a case-study tutorial on how to use AI copilot for the following three problems. You can list the AI tools you used, and how you designed and adjusted your prompts. You can add screenshots or even share the video of how you used these AI tools and the intermediate products generated by AI if you believe it will help the readers learn.



## Problem 1. Github Website for Your Coding Blog

Create a homepage for a website for your **coding blog**. The website should be hosted on [GitHub Pages](https://pages.github.com/). You can design the homepage by yourself in any proper style you like. You may need to make the design expandable to add more content from our future assignments. The link to the homepage should be added to the `README.md` of your homework repository so that anyone can access the homepage and the following two webpages from the Internet using this link.


## Problem 2. Game Coding: Pac-Man (Valentine's Special üíò)

Add a new page to your website for a Valentine's-themed [Pac-Man](https://en.wikipedia.org/wiki/Pac-Man) game. The users can directly play the game on your webpage. The link to the game webpage should be added to the homepage in Problem 1. Your game should include the following core features:

1. **Classic Pac-Man Mechanics**: A maze with dots (pellets) for Pac-Man to eat, and ghosts that chase Pac-Man. The game ends when Pac-Man loses all lives. You can decide the maze layout by yourself (classic ok, but maybe even 3D).
2. **Valentine's Power-Up ‚Äî Rose** üåπ: A rose randomly appears on the maze from time to time. When Pac-Man eats the rose, it enters a powered-up state for a limited duration (e.g., a few seconds), during which Pac-Man **continuously shoots hearts** in its current facing direction.
3. **Heart Projectiles** üíï: The hearts travel across the maze and eliminate any ghost they hit. Once the power-up expires, Pac-Man returns to normal until it picks up another rose.

As long as the game is recognizable as a Pac-Man game by common sense, with the features roughly following the above requirements, you will get full credit.

Beyond these requirements, you are free (but will not be graded) to add your own creative touches ‚Äî such as Valentine's-themed visuals, sound effects, scoring bonuses, or additional power-ups.

## Problem 3. Data Scaffolding from the Internet

In this problem, you will build an auto-updating arXiv paper feed for your website. **You must use Copilot CLI as your primary coding tools** to scaffold, implement, and automate this task. The goal is to practice the agentic programming paradigm: break the task into agent-friendly steps, prompt the agent effectively, and wire everything together.

We suggest you to follow the steps we showed in the class: plan first with AI to decide the workflow and agents orchestration, then ask AI to implement the plan.

### Deliverables

Add a new page to your website that displays the latest arXiv papers. The page must include:

1. **Paper Listing**: The latest arXiv papers matching keywords of your choice. Design the layout as you see fit.
2. **Paper Details**: Each entry must show the paper title, authors, abstract, and a direct link to the PDF.
3. **Auto-Update**: The paper list must refresh automatically every midnight via a GitHub Actions workflow.
4. **Homepage Link**: A link to this page must appear on your homepage from Problem 1.
5. **Page Design**: Style the page in any way you think readers would appreciate.

Your homework repository **must include the `.github` directory** with all agent configurations and workflow files used for this problem.

In your report (`README.md`), describe how you used Copilot CLI to build each component. Include the prompts you gave the agent and note what worked well or required iteration.

### Tips

**Tip 1**: You can ask AI how to deploy the website by [GitHub Pages](https://pages.github.com/). 

**Tip 2**: You can ask AI to teach you how to use [arXiv API](https://arxiv.org/help/api/user-manual) to fetch the latest papers from arXiv.

**Tip 3**: You can ask AI to teach you how to use [GitHub Actions](https://docs.github.com/en/actions) to automate the process of updating the webpage. Or even leave the job to agents.

**Tip 4**: You can use [Copy Coder](https://copycoder.ai/) to help you design the webpage UI from the style you like.

---

# Report: Building with AI Assistance

This section documents my journey using GitHub Copilot and AI coding assistants to complete all three problems. I had no prior experience with game development or GitHub Actions, so this was a learning experience in leveraging AI for unfamiliar tasks.

**Live Site**: [https://aalice-z.github.io/bst236-coding-blog/](https://aalice-z.github.io/bst236-coding-blog/)

## AI Tools Used
- **GitHub Copilot Chat** (VS Code extension) - Primary coding assistant
- **Agentic Programming Approach** - Breaking tasks into smaller, agent-friendly components

---

## Problem 1: GitHub Pages Website

### Initial Prompt
```
According to the Problem 1 requirements in README, list out steps to create the github website for my coding blog.
```

### What Worked Well
- **Single Clear Prompt**: The AI understood the requirement and generated a complete homepage with:
  - Modern responsive design
  - Navigation structure ready for future pages
  - Professional styling with CSS variables
  - Project cards for the Pac-Man game and arXiv feed

### Iterations Required
1. **Color Theme Adjustment**
   - **Prompt**: "I want pastel mint green and baby blue color theme"
   - **Result**: AI updated CSS variables to match the desired aesthetic
   - **Learning**: AI excels at design adjustments when given specific color preferences

2. **Deployment Challenge**
   - **Issue**: My repository was a GitHub Classroom fork without Pages sidebar
   - **Prompt**: "My repo was forked from classroom and don't have the pages sidebar. How to host the website repo under my own github account so I post it online."
   - **Solution**: AI guided me through creating a new personal repository and pushing code there
   - **Learning**: AI can provide detailed deployment guidance for complex GitHub workflows

### Key Takeaway
Start with a clear, requirement-based prompt. AI can generate complete, production-ready code when given proper context from documentation (the README in this case).

---

## Problem 2: Valentine's Pac-Man Game

### Initial Prompt
```
Now, continue to Problem 2, including the three key features described in README (provided context and listed the requirements)
```

### What Worked Well
- **Feature Implementation**: AI successfully created all three core features:
  - Classic maze-based Pac-Man mechanics
  - Rose power-ups with timed duration
  - Heart projectile system that eliminates ghosts
- **Game Loop Architecture**: Proper game loop with requestAnimationFrame
- **Canvas Rendering**: Efficient 2D canvas drawing

### Iterations Required

#### Iteration 1: Movement Issues
- **Problem**: "This looks a bit weird. the pac man becomes a triangular piece when running, and is in between blue and black blocks and can go anywhere not blocked by anything"
- **Root Cause**: Floating-point position system caused misalignment with grid
- **Solution**: AI implemented grid-based movement with smooth interpolation
- **Files Changed**: Completely rewrote movement logic in `pacman.html`

#### Iteration 2: Black Screen Bug
- **Problem**: "Now the screen is black."
- **Root Cause**: Pac-Man object not initialized before drawing
- **Solution**: Added proper initialization before initial draw
- **Learning**: AI quickly identified and fixed initialization order issues

#### Iteration 3: Syntax Errors
- **Problem**: "There are errors in the file"
- **Root Cause**: File corruption from multiple edits created malformed JavaScript
- **Solution**: AI recognized the issue and recreated the entire file cleanly
- **Files Changed**: Complete rewrite of `pacman.html` (661 lines)

#### Iteration 4: Ghost Positioning
- **Problem**: "This orange guy is staying in one place and cannot move because there is just one grid"
- **Root Cause**: Ghosts spawning inside walls
- **Solution**: AI created specific spawn positions in valid empty spaces
- **Learning**: Visual debugging through screenshots helped AI understand spatial issues

#### Iteration 5: Valentine's Theme
- **Prompt**: "can we have pink walls instead of blue to make it valentine's them"
- **Result**: Instant update from blue (#2121de) to hot pink (#ff69b4) walls
- **Learning**: Theme adjustments are trivial for AI when requested explicitly

### Key Challenges & Solutions

| Challenge | AI Solution | Code Impact |
|-----------|-------------|-------------|
| Grid alignment | Separate gridX/gridY from interpolation x/y | Major refactor |
| Collision detection | Check integer grid positions, not floats | Medium fix |
| Ghost AI | Random valid direction selection with wall checking | New algorithm |
| File corruption | Complete file regeneration | Full rewrite |

### Key Takeaway
Game development requires iterative debugging. AI is excellent at:
- Quickly diagnosing issues from descriptions or screenshots
- Implementing complete rewrites when needed
- Making incremental adjustments to game mechanics

However, expect multiple iterations for complex interactive systems. Each iteration refined the game until it worked smoothly.

---

## Problem 3: arXiv Paper Feed (Agentic Approach)

### Planning Phase

#### Initial Prompt
```
As a professional background data engineer, continue with Problem 3, Plan how to build the auto-updating arXiv paper feed using Copilot CLI. Teach me how to use arXiv API to fetch the latest papers from arXiv.
```

**AI Response**: Comprehensive plan breaking the task into 4 agents:
1. API Fetcher Agent (Python script)
2. Page Generator Agent (Python script)
3. Automation Agent (GitHub Actions)
4. Dependencies File

### Agent 1: API Fetcher Script

#### Prompt
```
Create a Python script fetch_papers.py that:
1. Takes keywords as command-line arguments
2. Queries arXiv API for the latest 20 papers matching those keywords
3. Parses the XML response
4. Extracts: title, authors, abstract, PDF link, published date
5. Saves results to papers.json
6. Uses requests library for HTTP and xml.etree for parsing
```

#### Result 
- **Generated**: Complete `fetch_papers.py` (185 lines)
- **Features Included**:
  - Command-line argument parsing
  - arXiv API query building (supports both keywords and categories)
  - XML parsing with proper namespaces
  - Error handling for network and parse errors
  - Date formatting for human readability
  - JSON output with metadata
- **First Run Success**: Script worked immediately without modifications
- **Test Output**: Successfully fetched 20 papers on "machine learning" and "deep learning"

### Agent 2: Page Generator Script

#### Prompt
```
Create a Python script generate_page.py that:
1. Reads papers.json
2. Generates papers.html with pastel mint green and baby blue theme
3. Displays papers in a responsive card grid
4. Each card shows: title (linked to PDF), authors, date, and abstract
5. Includes "Back to Home" link
6. Matches the style.css from the existing website
```

#### Result 
- **Generated**: Complete `generate_page.py` (235 lines)
- **Features Included**:
  - JSON parsing with error handling
  - HTML template generation with embedded CSS
  - Responsive grid layout (auto-adjusts columns)
  - Smart author truncation (shows "et al." for many authors)
  - Abstract truncation for long texts
  - Consistent theme using CSS variables
  - Multiple link types (PDF and arXiv page)
- **First Run Success**: Generated beautiful HTML page immediately

### Agent 3: GitHub Actions Workflow

#### Prompt
```
Create .github/workflows/update-papers.yml that:
1. Runs daily at midnight UTC (cron: '0 0 * * *')
2. Also allows manual triggering
3. Checks out the repository
4. Sets up Python 3.11
5. Installs dependencies from requirements.txt
6. Runs fetch_papers.py with keywords "machine learning"
7. Runs generate_page.py
8. Commits and pushes changes if papers.json or papers.html changed
9. Uses github-actions bot for commits
```

#### Result 
- **Generated**: Complete workflow file (74 lines)
- **Features Included**:
  - Cron schedule for daily runs
  - Manual trigger capability (`workflow_dispatch`)
  - Proper Python setup with pip caching
  - Change detection before committing
  - Conditional commit/push
  - Proper git configuration for bot commits
  - Helpful logging messages
- **Additional**: AI created detailed setup instructions (`GITHUB_ACTIONS_SETUP.md`)

### What Worked Exceptionally Well 

1. **Agentic Breakdown**: The AI naturally decomposed the problem into independent, testable components
2. **Documentation Quality**: Each script had comprehensive docstrings and comments
3. **Error Handling**: All scripts included proper try-except blocks and user-friendly error messages
4. **First-Time Success Rate**: All three components worked on first execution
5. **Production Ready**: Code included features I didn't explicitly request:
   - Summary statistics after execution
   - Progress logging
   - Smart defaults when no arguments provided
   - Responsive design breakpoints

### Minimal Iterations Required 

**Question**: "Do I need dependencies file?"
- AI clarified that `requirements.txt` was already created in Step 1
- Explained why only `requests` was needed (other modules are Python stdlib)
- No code changes needed

### Key Takeaway

The agentic approach is powerful for data engineering tasks:
1. **Plan First**: Ask AI to design the architecture before coding
2. **One Agent = One Script**: Clear separation of concerns
3. **Test Incrementally**: Each component can be tested independently
4. **Compose Together**: GitHub Actions orchestrates all pieces

This approach resulted in:
- **Zero debugging needed** for the data pipeline
- **Clean, maintainable code** with proper structure
- **Production-ready automation** on first try

---

## Overall Lessons Learned

### What AI Excels At
1. **Complete System Generation**: Given clear requirements, AI generates entire functional systems
2. **Quick Iteration**: Fast turnaround on bug fixes and feature adjustments
3. **Best Practices**: Automatically includes error handling, documentation, and edge cases
4. **Architecture Guidance**: Excellent at planning multi-component systems

### Where Human Guidance Is Critical
1. **Visual Debugging**: Describing visual bugs (like Pac-Man movement) requires precise observation
2. **Requirement Interpretation**: Translating assignment requirements into specific prompts
3. **Testing & Validation**: Verifying outputs match expectations
4. **Design Decisions**: Choosing color schemes, keywords, and user experience

### Prompt Engineering Tips

#### Effective Prompts
- Reference existing documentation (e.g., "according to README requirements")
- Be specific about desired features (numbered lists work well)
- Include technical constraints (Python version, libraries to use)
- Request specific file names and structures

#### What Doesn't Work Well
- Vague requests like "make it better"
- Assuming AI knows your setup (be explicit about environment)
- Multiple unrelated changes in one prompt

### The Iterative Process

```
Initial Prompt ‚Üí AI Generation ‚Üí Testing ‚Üí Issue Found ‚Üí 
Specific Bug Report ‚Üí AI Fix ‚Üí Retesting ‚Üí Success!
```

**Average iterations needed**:
- Problem 1 (Homepage): 2 iterations (mainly design tweaks)
- Problem 2 (Game): 5 iterations (complex interactive system)
- Problem 3 (Data Pipeline): 1 iteration (well-structured from planning)

---

## üöÄ Deployment & Access

- **Homepage**: [https://aalice-z.github.io/bst236-coding-blog/](https://aalice-z.github.io/bst236-coding-blog/)
- **Pac-Man Game**: [https://aalice-z.github.io/bst236-coding-blog/pacman.html](https://aalice-z.github.io/bst236-coding-blog/pacman.html)
- **arXiv Papers**: [https://aalice-z.github.io/bst236-coding-blog/papers.html](https://aalice-z.github.io/bst236-coding-blog/papers.html)
- **Auto-Update**: Daily at midnight UTC via GitHub Actions

---

## Conclusion

This homework demonstrated that AI coding assistants are incredibly powerful when:
1. Given clear, specific requirements
2. Used iteratively with testing and feedback
3. Applied to well-defined problem domains

The agentic programming paradigm (breaking problems into independent agents) proved especially effective for the data pipeline, resulting in cleaner code and faster development.

The key skill isn't writing code anymore‚Äîit's **communicating requirements clearly** and **debugging systematically** when issues arise.


